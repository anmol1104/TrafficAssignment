using DataFrames
using CSV
using Random
using Calculus
using Printf
using StatsBase
using Dates
using JLD
Random.seed!(1403)
cd(@__DIR__)

"""
    traffic_assignment(;networkName[, assignment, initialSol, tol, maxIters, maxRunTime, log])

improved Traffic Assignment by Paired Alternative Segments (iTAPAS) algorithm for static multi-class 
traffic assignment problem with generalized link cost function.
 
### Generalized link cost function: `c·µê·µ¢‚±º = f·µê(v·µ¢‚±º)t·µ¢‚±º`
- `c·µê·µ¢‚±º` : generalized link cost for link ùëñùëó , vehicle class ùëö
- `t·µ¢‚±º`  : travel time on link ùëñùëó
- `v·µ¢‚±º`  : travel speed on link ùëñùëó
- `f·µê(v)`: rate function (\$ per hr) for vehicle class ùëö, `f·µê(v) = ‚àë‚Çñ Œ∑·µèv·µè`

### Required properties of the generalized cost function
- Strictly positive
- Monotonically non-decreasing
- Continuously differentiable

### Arguments
- `networkName`::String         : network from the repository https://github.com/anmol1104/TrafficAssignment
- `assignment`::Symbol=:UE      : User Equilibrium (UE) or System Optimal (SO) assigment
- `tol`::Float=1e-5             : tolerance level for relative gap convergence
- `maxIters`::Integer=20        : maximum number of iterations
- `maxRunTime`::Integer=600     : maximum wall clock run time (s)
- `log`::Symbol=:on             : shows results for every iteration if log is on

### DataFiles (available at: https://github.com/anmol1104/TrafficAssignment)
- class   : Enlists coefficients of `f·µê(v)` for each class
- network : Details the topology of the network
- demand  : Enlists OD pairs and corresponding demand for each class in passenger car equivalent (PCE)

### IO Units
- length  : miles
- time    : hour
- volume  : litre
- mass    : kg
- cost    : \$
"""
function traffic_assignment(;networkName, assignment=:UE, tol=1e-5, maxIters=20, maxRunTime=600, log=:on)
    println()
    printstyled("\niTAPAS Algorithm", color=:blue)

    # Algorithm parameters
    N   = Int64[]                               # Nodes
    A   = Array{Int64,1}[]                      # Arcs as adjacency list
    M   = Int64[]                               # Modes/classes
    V·µ¢‚±º = Array{Float64,1}[]                    # Link volume capcity
    d·µ¢‚±º = Array{Float64,1}[]                    # Link length
    t·µ¢‚±º = Array{Float64,1}[]                    # Link free flow travel time
    Œ±·µ¢‚±º = Array{Float64,1}[]                    # BPR parameters
    Œ≤·µ¢‚±º = Array{Float64,1}[]                    # BPR parameters
    R   = Int64[]                               # Origins
    M·µ£  = Dict{Int64,Int64}()                   # Mode/class assosciated with every origin
    S·µ£  = Dict{Int64,Array{Int64,1}}()          # Destinations for every origin
    q·µ£  = Dict{Tuple{Int64,Int64},Float64}()    # Demand between OD pairs
    Œ∑   = Array{Float64,1}[]                    # Coefficients for the polynomial f·µê(v)

    œï   = Array{Int64,1}[]
    Œ≥   = Array{Array{Int64,1},1}[]

    # Network build
    # Fetches betwork files and builds network related vectors
    function build()
        # class file
        clssFile = "Network\\$networkName\\class.csv"
        csv‚ÇÅ = CSV.File(clssFile)
        df‚ÇÅ = DataFrame(csv‚ÇÅ)
        for m in 1:nrow(df‚ÇÅ)
            push!(M,m)
            push!(Œ∑, [df‚ÇÅ[m, c] for c in 2:ncol(df‚ÇÅ)])
        end

        # network file
        ntwkFile = "Network\\$networkName\\network.csv"
        csv‚ÇÇ = CSV.File(ntwkFile, types=[Int64, Int64, Float64, Float64, Float64, Float64, Float64])
        df‚ÇÇ = DataFrame(csv‚ÇÇ)
        head = df‚ÇÇ[!, 1]::Array{Int64,1}
        tail = df‚ÇÇ[!, 2]::Array{Int64,1}
        linkcapacity = df‚ÇÇ[!, 3]::Array{Float64,1}
        linklength = df‚ÇÇ[!, 4]::Array{Float64,1}
        linkfft = df‚ÇÇ[!, 5]::Array{Float64,1}
        alpha = df‚ÇÇ[!, 6]::Array{Float64,1}
        beta = df‚ÇÇ[!, 7]::Array{Float64,1}
        n = max(maximum(head), maximum(tail))
        for i in 1:n
            push!(N, i)
            push!(A, [])
            push!(V·µ¢‚±º, [])
            push!(d·µ¢‚±º, [])
            push!(t·µ¢‚±º, [])
            push!(Œ±·µ¢‚±º, [])
            push!(Œ≤·µ¢‚±º, [])
            push!(œï, [])
        end
        for i in 1:length(head)
            push!(A[head[i]], tail[i])
            push!(V·µ¢‚±º[head[i]], linkcapacity[i])
            push!(d·µ¢‚±º[head[i]], linklength[i])
            push!(t·µ¢‚±º[head[i]], linkfft[i])
            push!(Œ±·µ¢‚±º[head[i]], alpha[i])
            push!(Œ≤·µ¢‚±º[head[i]], beta[i])
            push!(œï[head[i]], 1)
        end

        # geofencing file
        if "geofence.csv" ‚àà readdir("Network\\$networkName\\")
            geofFile = "Network\\$networkName\\geofence.csv"
            csv‚ÇÉ = CSV.File(geofFile)
            df‚ÇÉ = DataFrame(csv‚ÇÉ)
            for m in M
                push!(Œ≥, [[] for i in N])
                for r in 1:nrow(df‚ÇÉ)
                    i = df‚ÇÉ[r,1]::Int64
                    push!(Œ≥[m][i], df‚ÇÉ[r,m+2])
                end
            end
        else
            for m in M push!(Œ≥, [[0 for j in A[i]] for i in N]) end
        end

        # demand file
        dmndFile = "Network\\$networkName\\demand.csv"
        csv‚ÇÑ = CSV.File(dmndFile)
        df‚ÇÑ = DataFrame(csv‚ÇÑ)
        origin = df‚ÇÑ[!, 1]::Array{Int64,1}
        destination = df‚ÇÑ[!, 2]::Array{Int64,1}
        flows = df‚ÇÑ[!, 3:ncol(df‚ÇÑ)]::DataFrame
        dict = Dict{Int64,Array{Int64,1}}(r => [r] for r in unique(origin))
        for m in 2:length(M)
            for r‚Çí in unique(origin)
                r = length(N) + 1
                push!(N, r)
                push!(A[r‚Çí], r), push!(A, [r‚Çí])
                push!(V·µ¢‚±º[r‚Çí], 1.0), push!(V·µ¢‚±º, [1.0])
                push!(d·µ¢‚±º[r‚Çí], 0.0), push!(d·µ¢‚±º, [0.0])
                push!(t·µ¢‚±º[r‚Çí], 0.001), push!(t·µ¢‚±º, [0.001])
                push!(Œ±·µ¢‚±º[r‚Çí], 0.0), push!(Œ±·µ¢‚±º, [0.0])
                push!(Œ≤·µ¢‚±º[r‚Çí], 0.0), push!(Œ≤·µ¢‚±º, [0.0])
                push!(œï[r‚Çí], 0), push!(œï, [0])
                push!(dict[r‚Çí], r)
                for k in M push!(Œ≥[k][r‚Çí], 0), push!(Œ≥[k], [0]) end
            end
        end
        for i in 1:nrow(df‚ÇÑ)
            r‚Çí = origin[i]
            for j in 1:(ncol(df‚ÇÑ)-2)
                r, s, m = dict[r‚Çí][j], destination[i], j
                if r ‚àâ R S·µ£[r] = [] end
                if r ‚àâ R push!(R, r) end
                push!(S·µ£[r], s)
                M·µ£[r] = m
                q·µ£[(r,s)] = flows[i,j]
            end
        end
    end

    # Arc cost
    # Returns cost of arc (i,j) for class m given arc flow x (k = A[i]‚Åª¬π(j))
    function c·µ¢‚±º(i, k, m, x, method)
        #j = A[i][k]

        Œ± = Œ±·µ¢‚±º[i][k]
        Œ≤ = Œ≤·µ¢‚±º[i][k]
        t‚Çí= t·µ¢‚±º[i][k]
        V = V·µ¢‚±º[i][k]

        t = t‚Çí * (1 + Œ± * (abs(x)/V) ^ Œ≤)
        d = d·µ¢‚±º[i][k]
        v = d/t
        if v == Inf v = 1.0e6 end

        c = 0.0
        if method == :UE for k in 0:(length(Œ∑[m])-1) c += Œ∑[m][k+1] * v^k * t end end
        if method == :SO
            t‚Ä≤ = t‚Çí * Œ± * Œ≤ * (abs(x) ^ (Œ≤ - 1))/(V ^ Œ≤)
            if Œ≤ == 0 t‚Ä≤ = 0.0 end
            if t‚Ä≤ == Inf t‚Ä≤ = 1.0e6 end
            for k in 0:(length(Œ∑[m])-1) c += Œ∑[m][k+1] * v^k * (t + x * t‚Ä≤ * (1 - k)) end
        end
        c = c * (1 + Œ≥[m][i][k]*(1))
        return c
    end

    # Arc cost derivative
    # Returns derivative of cost of arc (i,j) at arc flow x (k = A[i]‚Åª¬π(j))
    function c‚Ä≤·µ¢‚±º(i, k, m, x, method)
        #j = A[i][k]

        Œ± = Œ±·µ¢‚±º[i][k]
        Œ≤ = Œ≤·µ¢‚±º[i][k]
        t‚Çí= t·µ¢‚±º[i][k]
        V = V·µ¢‚±º[i][k]

        t = t‚Çí * (1 + Œ± * (abs(x)/V) ^ Œ≤)
        d = d·µ¢‚±º[i][k]
        v = d/t
        if v == Inf v = 1.0e6 end

        t‚Ä≤ = t‚Çí * Œ± * Œ≤ * (abs(x) ^ (Œ≤ - 1))/(V ^ Œ≤)
        if Œ≤ == 0 t‚Ä≤ = 0.0 end
        if t‚Ä≤ == Inf t‚Ä≤ = 1.0e6 end

        c‚Ä≤ = 0.0
        if method == :UE for k in 0:(length(Œ∑[m])-1) c‚Ä≤ += Œ∑[m][k+1] * v^k * (1 - k) * t‚Ä≤ end end
        if method == :SO
            t‚Ä≤‚Ä≤ = t‚Çí * Œ± * Œ≤ * (Œ≤ - 1) * (abs(x) ^ (Œ≤ - 2))/(V ^ Œ≤)
            if Œ≤ == 0 || Œ≤ == 1 t‚Ä≤‚Ä≤ = 0.0 end
            if t‚Ä≤‚Ä≤ == Inf t‚Ä≤‚Ä≤ = 1.0e6 end
            for k in 0:(length(Œ∑[m])-1)
                c‚Ä≤ += Œ∑[m][k+1] * v^k * (1-k) * (2t‚Ä≤ + x*(t‚Ä≤‚Ä≤ - k*(t‚Ä≤^2)/t))
            end
        end
        c‚Ä≤ = c‚Ä≤ * (1 + Œ≥[m][i][k]*(1))
        return c‚Ä≤
    end

    # Segment cost
    # Returns cost for segment e given arc flows x‚Çê and arc costs c
    function c‚Çë(e, c‚Çê)
        c = 0.0
        for (n,i) in enumerate(e[1:end-1])
            j = e[n+1]
            k = findfirst(x -> (x == j), A[i])::Int64
            c += c‚Çê[i][k]
        end
        return c
    end

    # Segment flow
    # Returns flow on segment e given arc flows x‚Çê
    function f‚Çë(e, x‚Çê)
        f = zeros(length(e)-1)
        for (n,i) in enumerate(e[1:end-1])
            j = e[n+1]
            k = findfirst(x -> (x == j), A[i])::Int64
            f[n] = x‚Çê[i][k]
        end
        return minimum(f)
    end

    # Djikstra's label setting algorithm
    # Returns predecessor label L for every node i for least cost path from node r given arc costs c‚Çê
    function djk(c‚Çê, r)
        L = [if i == r r else -1 end for i in N]       # Predecessor label
        C = [if i == r 0.0 else Inf end for i in N]    # Cost label
        X = copy(N)                                    # Set of open nodes
        i = r
        deleteat!(X, i)
        while !isempty(X)
            for (k,j) in enumerate(A[i])
                c = C[i] + c‚Çê[i][k]
                if c < C[j] && j in X L[j], C[j] = i, c end
            end
            index = argmin([C[i] for i in X])
            i = X[index]
            deleteat!(X, index)
        end
        return L
    end

    # Tree
    # Returns tree rooted at r given predecessor label L
    function tree(L, r)
        T = Array{Int64,1}[[] for j in N]
        for j in N
            i = L[j]
            if i ‚â† j && i ‚â† -1 push!(T[i], j) end
        end
        return T
    end

    # Path
    # Returns path between node r and s using predecessor label L
    function path(L, r, s)
        p = Int64[]
        i = s
        push!(p, i)
        while i ‚â† r
            i = Int(L[i])
            push!(p, i)
        end
        reverse!(p)
        return p
    end

    # improved Traffic Assignment with Paired Alterantive Segments (iTAPAS)
    # Returns excel file with arc flows and arc cost for each class, and a log of iterations
    function iTAPAS(œµ, Œ∏, writeout)
        report = Dict("TF" => Float64[], "TC" => Float64[], "RG" => Float64[], "WT" => Float64[])

        x ≥‚Çê = Dict(r => [[0.0 for j in A[i]] for i in N] for r in R)                                     # Stores origin-based arc flows
        x‚Çê  = [[sum([x ≥‚Çê[r][i][k] for r in R]) for k in 1:length(A[i])] for i in N]                      # Stores arc flows
        c‚Çê  = [[[c·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment) for k in 1:length(A[i])] for i in N] for m in M]     # Stores arc cost
        c‚Ä≤‚Çê = [[[c‚Ä≤·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment) for k in 1:length(A[i])] for i in N] for m in M]    # Stores derivative of arc cost
        œÄ ≥‚Çê = Dict(r => [[0.0 for j in A[i]] for i in N] for r in R)                                     # Stores arc reduced cost
        r‚Çö = Int64[]                                                                                      # Stores origin for PAS p
        P = Tuple{Array{Int64,1},Array{Int64,1}}[]                                                       # Stores PAS
        L·µ£ = Dict(r => [if i==r r else -1 end for i in N] for r in R)                                    # Stores origin-based least cost lables

        # Checks if arc a fails reduced cost optimal conditions for origin r
        function ispotential(a, r)
            i, j = a
            m = M·µ£[r]
            k = findfirst(x -> (x == j), A[i])::Int64
            p·µ£·µ¢ = path(L·µ£[r], r, i)
            p·µ£‚±º = path(L·µ£[r], r, j)
            u ≥·µ¢ = c‚Çë(p·µ£·µ¢, c‚Çê[m])
            u ≥‚±º = c‚Çë(p·µ£‚±º, c‚Çê[m])
            c ≥·µ¢‚±º = c‚Çê[m][i][k]
            œÄ ≥·µ¢‚±º = u ≥·µ¢ + c ≥·µ¢‚±º - u ≥‚±º
            if x ≥‚Çê[r][i][k] > œµ && œÄ ≥·µ¢‚±º > Œ∏ return (true, œÄ ≥·µ¢‚±º)
            else return (false, 0.0) end
        end

        # Checks if PAS p assosciated with origin r‚Çí can be eliminated
        function isbad(p, r‚Çí)
            e‚ÇÅ, e‚ÇÇ = p
            m = M·µ£[r‚Çí]
            c‚ÇÅ, c‚ÇÇ = c‚Çë(e‚ÇÅ, c‚Çê[m]), c‚Çë(e‚ÇÇ, c‚Çê[m])
            f‚ÇÅ, f‚ÇÇ = f‚Çë(e‚ÇÅ, x ≥‚Çê[r‚Çí]), f‚Çë(e‚ÇÇ, x ≥‚Çê[r‚Çí])
            if (f‚ÇÅ < œµ || f‚ÇÇ < œµ) && (c‚ÇÅ ‚â† c‚ÇÇ) return true
            else return false end
        end

        # Shifts flows from higher cost segment to lower cost segment of PAS p 
        # on its assosciated origin r‚Çí, given cost difference is greater than Œª
        function shift(p, r‚Çí, Œª)
            e‚ÇÅ, e‚ÇÇ = p
            m = M·µ£[r‚Çí]

            c‚ÇÅ, c‚ÇÇ = c‚Çë(e‚ÇÅ, c‚Çê[m]), c‚Çë(e‚ÇÇ, c‚Çê[m])
            if abs(c‚ÇÇ - c‚ÇÅ) < Œª return end

            c‚Ä≤‚ÇÅ, c‚Ä≤‚ÇÇ = c‚Çë(e‚ÇÅ, c‚Ä≤‚Çê[m]), c‚Çë(e‚ÇÇ, c‚Ä≤‚Çê[m])
            f‚ÇÅ, f‚ÇÇ = f‚Çë(e‚ÇÅ, x ≥‚Çê[r‚Çí]), f‚Çë(e‚ÇÇ, x ≥‚Çê[r‚Çí])
            Œî = (c‚ÇÇ - c‚ÇÅ)/(c‚Ä≤‚ÇÅ + c‚Ä≤‚ÇÇ)
            if isnan(Œî) Œ¥ = 0.0
            elseif Œî ‚â• 0 Œ¥ = min(Œî, f‚ÇÇ)
            else Œ¥ = max(Œî, -f‚ÇÅ) end

            for (n,i) in enumerate(e‚ÇÅ[1:end-1])
                j = e‚ÇÅ[n+1]
                k = findfirst(x -> (x == j), A[i])::Int64
                x ≥‚Çê[r‚Çí][i][k] += Œ¥
                x‚Çê[i][k] += Œ¥
                for m in M
                    c‚Çê[m][i][k] = c·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                    c‚Ä≤‚Çê[m][i][k] = c‚Ä≤·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                end
            end
            for (n,i) in enumerate(e‚ÇÇ[1:end-1])
                j = e‚ÇÇ[n+1]
                k = findfirst(x -> (x == j), A[i])::Int64
                x ≥‚Çê[r‚Çí][i][k] -= Œ¥
                x‚Çê[i][k] -= Œ¥
                for m in M
                    c‚Çê[m][i][k] = c·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                    c‚Ä≤‚Çê[m][i][k] = c‚Ä≤·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                end
            end
        end

        # PAS identification for arc a wrt origin r using Maximum Cost Search
        function MCS(a, r)
            depth, maxdepth = 1, 2
            flag = true

            i, j = a
            e‚ÇÅ, e‚ÇÇ = Int64[], Int64[]
            p·µ£‚±º = path(L·µ£[r], r, j)

            while flag
                # Intialize
                l‚Çñ = [if k ‚àà a 1 elseif k ‚àâ p·µ£‚±º 0 else -1 end for k in N]
                L = [if k == j i else -1 end for k in N]

                # Iterate
                t = i
                while true
                    h = t

                    f = 0.0
                    for i in N
                        k = findfirst(x -> (x == h), A[i])
                        if k != nothing
                            x = x ≥‚Çê[r][i][k]
                            m = M·µ£[r]
                            c = c·µ¢‚±º(i, k, m, x, assignment)
                            if x > œµ && c > f
                                f, t = c, i
                            end
                        end
                    end
                    L[h] = t
                    if l‚Çñ[t] == -1      # PAS found
                        e‚ÇÅ = path(L·µ£[r], t, j)
                        e‚ÇÇ = path(L, t, j)
                        shift((e‚ÇÅ, e‚ÇÇ), r, 0)
                        bool,_ = ispotential(a, r)
                        if !bool || depth == maxdepth flag = false
                        else depth += 1 end
                        break
                    elseif l‚Çñ[t] == 1   # Cycle found
                        if depth == maxdepth flag = false
                        else
                            if h == t p‚Çï‚Çú = Int64[]
                            else
                                p‚Çï‚Çú = path(L, h, t)
                                push!(p‚Çï‚Çú, h)
                                Œ¥ = f‚Çë(p‚Çï‚Çú, x ≥‚Çê[r])
                            end
                            for (n,i) in enumerate(p‚Çï‚Çú[1:end-1])
                                k = findfirst(x -> (x == p‚Çï‚Çú[n+1]), A[i])::Int64
                                x ≥‚Çê[r][i][k] -= Œ¥
                                x‚Çê[i][k] -= Œ¥
                                for m in M
                                    c‚Çê[m][i][k] = c·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                                    c‚Ä≤‚Çê[m][i][k] = c‚Ä≤·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                                end
                            end
                            depth += 1
                        end
                        break
                    else                # Continue
                        l‚Çñ[t] = 1
                    end
                end
            end
            p = (e‚ÇÅ, e‚ÇÇ)
            return p
        end


        if log == :on
            print("\n iter: iteration,  RG:Relative Gap,  TF:Total Flow,  TC: Total Cost,  WT: Wall Time (s)")
            print("\n iter  | logRG      | TF          | TC          | WT (s) ")
            print("\n ------|------------|-------------|-------------|--------")
        end

        ## Step 0: Intialization - AON assignment
        T =  Dates.format(now(), "HH:MM:SS:sss")
        t‚Çí = parse.(Int64, [T[1:2], T[4:5], T[7:8], T[10:12]])
        wt = 0.0
        iter = 0
        for r in R
            m = M·µ£[r]
            L·µ£[r] = djk(c‚Çê[m], r)
            for s in S·µ£[r]
                q·µ£‚Çõ = q·µ£[r,s]
                p·µ£‚Çõ = path(L·µ£[r], r, s)
                for (n,i) in enumerate(p·µ£‚Çõ[1:end-1])
                    j = p·µ£‚Çõ[n+1]
                    k = findfirst(x -> (x == j), A[i])
                    x ≥‚Çê[r][i][k] += q·µ£‚Çõ
                    x‚Çê[i][k] += q·µ£‚Çõ
                    for m in M
                        c‚Çê[m][i][k] = c·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                        c‚Ä≤‚Çê[m][i][k] = c‚Ä≤·µ¢‚±º(i, k, m, x‚Çê[i][k], assignment)
                    end
                end
            end
        end

        # Iterate
        while true
            # Run Time
            T =  Dates.format(now(), "HH:MM:SS:sss")
            t‚Çô = parse.(Int64, [T[1:2], T[4:5], T[7:8], T[10:12]])
            wt = sum((t‚Çô - t‚Çí) .* [3600, 60, 1, 1/1000])

            # Relative Gap
            for r in R L·µ£[r] = djk(c‚Çê[M·µ£[r]], r) end
            num, den = 0.0, 0.0
            for r in R for s in S·µ£[r] num += q·µ£[r,s] * c‚Çë(path(L·µ£[r], r, s), c‚Çê[M·µ£[r]]) end end
            for r in R for i in N for k in 1:length(A[i]) den += x ≥‚Çê[r][i][k] * c‚Çê[M·µ£[r]][i][k] end end end
            rg = 1 - num/den

            # Total network flow and cost
            tf = sum(sum.(x‚Çê))
            tc = 0.0
            for r in R for i in N for k in 1:length(A[i]) tc += x ≥‚Çê[r][i][k] * c·µ¢‚±º(i, k, M·µ£[r], x‚Çê[i][k], :UE) end end end

            # Miscellaneous
            append!(report["RG"], log10(abs(rg)))
            append!(report["TF"], tf)
            append!(report["TC"], tc)
            append!(report["WT"], wt)
            if log == :on
                if iter < 10 @printf("\n #%.0f    | %.3E | %.5E | %.5E | %.3f  ", iter, log10(abs(rg)), tf, tc, wt)
                else @printf("\n #%.0f   | %.3E | %.5E | %.5E |%.3f ", iter, log10(abs(rg)), tf, tc, wt) end
            end

            # Convergence Test
            if log10(abs(rg)) ‚â§ log10(tol) || iter ‚â• maxIters || wt ‚â• maxRunTime break end
            iter += 1

            ## Step 1
            for r in R
                m = M·µ£[r]
                L·µ£[r] = djk(c‚Çê[m], r)
                T·µ£ = tree(L·µ£[r], r)
                ## Step 1.1: Indentify potential arcs
                for i in N
                    for (k,j) in enumerate(A[i])
                        a = (i, j)
                        bool, œÄ ≥·µ¢‚±º = false, 0.0
                        if j ‚àâ T·µ£[i] bool, œÄ ≥·µ¢‚±º = ispotential(a, r) end
                        œÄ ≥‚Çê[r][i][k] = œÄ ≥·µ¢‚±º
                        ## Step 1.2: Flow shift for potential arc
                        if bool
                            p = MCS(a,r)
                            e‚ÇÅ, e‚ÇÇ = p
                            r‚Çí = r
                            if !isempty(e‚ÇÅ) && !isempty(e‚ÇÇ) && p ‚àâ P push!(P, p), append!(r‚Çö, r‚Çí) end
                        end
                    end
                end
                # Step 1.3: Local shift
                for (k,p) in enumerate(P) shift(p, r‚Çö[k], rg/1000) end
            end
            ## Step 2
            for _ in 1:20
                for (k,p) in enumerate(P)
                    if isbad(p, r‚Çö[k]) deleteat!(P, k), deleteat!(r‚Çö, k)
                    else shift(p, r‚Çö[k], rg/1000) end
                end
            end
        end

        # Writing out files
        if writeout
            df‚ÇÅ = DataFrame(from = Int64[], to = Int64[])
            for m in M df‚ÇÅ[!, Symbol("flow class $m")] = Float64[] end
            for m in M df‚ÇÅ[!, Symbol("cost class $m")] = Float64[] end
            for i in N
                for (k,j) in enumerate(A[i])
                    if œï[i][k] == 1
                        push!(df‚ÇÅ[!, :from], i)
                        push!(df‚ÇÅ[!, :to], j)
                        for m in M
                            x·µê = 0.0
                            for r in R if M·µ£[r] == m x·µê += x ≥‚Çê[r][i][k] end end
                            push!(df‚ÇÅ[!, Symbol("flow class $m")], x·µê)
                        end
                        for m in M push!(df‚ÇÅ[!, Symbol("cost class $m")], c·µ¢‚±º(i, k, m, x‚Çê[i][k], :UE)) end
                    end
                end
            end
            df‚ÇÇ = DataFrame(ITER = [i for i in 1:length(report["TF"])],
                            TF = report["TF"], TC = report["TC"],
                            LOGRG = report["RG"], WT = report["WT"])
            CSV.write("Network\\$networkName\\output-$assignment.csv", df‚ÇÅ)
            CSV.write("Network\\$networkName\\report-$assignment.csv", df‚ÇÇ)
        end
        println("\n")
        println("   Total run time: $wt")
        println("   Total network flow: $(sum([x ≥‚Çê[r][i][k] * œï[i][k] for r in R for i in N for k in 1:length(A[i])]))")
        println("   Total network cost: $(sum([x ≥‚Çê[r][i][k] * c·µ¢‚±º(i, k, M·µ£[r], x‚Çê[i][k], :UE) * œï[i][k] for r in R for i in N for k in 1:length(A[i])]))")
        return
    end

    build()
    iTAPAS(1e-12, 1e-16, true)
end
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

traffic_assignment(networkName = "SCAG")
    
# TODO: Test against benchmarks from Xie, Nie and Liu (2018) - A greedy path based algorithm
